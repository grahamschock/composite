/**
 * Redistribution of this file is permitted under the BSD two clause license.
 *
 * Copyright 2020, The George Washington University
 * Author: Gabriel Parmer, gparmer@gwu.edu
 */

#ifndef STATIC_ALLOC_H
#define STATIC_ALLOC_H

#include <ps.h>
#include <cos_debug.h>

/**
 * A memory allocator for statically-allocated collections of
 * objects. Similar to an API, and a baby version of parsec
 * namespaces. Objects are tracked as state machines of object
 * initialization, use, and freeing. This structure supports *indexed*
 * lookups, thus providing a facility to map a token/descriptor to an
 * object. This is mainly useful in system code that shares these
 * descriptors between protection domains (where pointers are
 * invalid). The implementation tracks the allocation state of an
 * object, *and* provides some rudimentary synchronization for indexed
 * lookups.
 *
 * The API is generated by the `SA_STATIC_ALLOC` macro, specialized to
 * the specific type. This enables the alignment constraints of the
 * underlying type to be factored into the global allocation, and
 * avoids magic math based on the size of the object type. It also
 * mimics the typical slab allocator interface.
 *
 * *The API*:
 * - `SA_STATIC_ALLOC(name, type, max_num_objects)` - Create the global
 *   memory for the objects to be able to allocate `max_num_objects`
 *   number of objects, and the following functions.
 * - `type *sa_name_alloc()` - Allocate a new object of the
 *   specified type. This is not fast. It is linear in max_num_objects.
 * - `void sa_name_free(type *obj)` - Free an allocated object,
 *   `obj`.
 * - `type *sa_name_alloc_at_index(unsigned int idx)` -
 *   Allocate an object at a descriptor `idx`.
 * - `void sa_name_activate(type *obj)` - Made an object
 *   accessible through indexed lookups.
 * - `type *sa_name_get(unsigned int idx) - Lookup an object via
 *   descriptor `idx` and return it if it is active.
 * - `unsigned int sa_name_index(type *obj)` - return the index
 *   of the object.
 *
 * *Example*:
 * ```
 * SA_STATIC_ALLOC(comp, struct crt_comp, MAX_NUM_COMPS);
 *
 * struct crt_comp *
 * comp_alloc(compid_t *cid)
 * {
 * 	struct crt_comp *c = sa_comp_alloc();
 *
 * 	if (!c) return NULL;
 * 	*cid = sa_comp_index(c);
 * 	// initialize the component
 * 	sa_comp_activate(c);
 *
 * 	return c;
 * }
 *
 * int
 * comp_free(compid_t id)
 * {
 * 	struct crt_comp *c sa_comp_get(id);
 *
 * 	if (!c) return -ENVAL;
 * 	sa_comp_free(c);
 *
 *	return 0;
 * }
 * ```
 *
 * *Synchronization*: It is important to further discuss the
 * interaction between `activate` and `get`. An object transitions
 * from `free` to `constructing` to denote that it's memory is in use,
 * but it is *not* yet accessible for indexed lookups. At this point,
 * an indexed lookup will return false. After the object is
 * initialized properly (denoted by `*_activate`), it transitions into
 * `allocated` and accessible for indexed lookups.
 *
 * This is all of the synchronization necessary to track allocations,
 * and for objects that are read-only, or can handle modification in
 * place (e.g. by wrapping them with a lock, or using atomic
 * instructions).
 *
 * *Allocator metadata*: The implementation uses a separation between
 * meta-data (allocation states) from the allocated memory. It
 * allocates a word to each object's meta-data, thus giving a wastage
 * fraction of sizeof(word_t)/(sizeof(type) + sizeof(word_t)). We
 * don't use bitfields for the meta-data as we don't want potential
 * cas contention *between* different objects. This would require
 * unbounded `cas` loops that are unacceptable. We pay for this with
 * some memory wastage.
 *
 * *Guarantees*:
 *
 * - All allocation is through the static array. No dynamic allocation.
 * - Constant-time (array indexed) `get`.
 * - Constant-time `alloc_at_index`.
 * - Objects are laid out contiguously. Alignment constraints should
 *   be embedded into your object/struct type, and they are honored.
 * - Statically allocated memory is BSS-allocated.
 * - Atomic instruction-guaranteed failure of `get` if an object has
 *   not been `activate`d.
 *
 * *Assumptions*:
 *
 * - This macro must be used in the same compilation object (`.o`) in
 *   which it is used. It does *not* generate function prototypes to
 *   be exported, and all data is `static`. Wrap these if you want to
 *   export them. The main macro should *never* be used in a header.
 * - After allocation and preparation of the object, you'll call
 *   `activated` if you're using the indexed allocation mechanism.
 * - The implementation uses `cas` to prevent races on allocation.
 */

/* Should be used with the type word_t to ensure word-aligned cas operations */
#define SA_OBJ_FREE         0
#define SA_OBJ_CONSTRUCTING 1
#define SA_OBJ_ALLOCATED    2

#define SA_STATIC_ALLOC(name, type, max_num)				\
	static word_t sa_##name##_states[max_num];			\
	static type sa_##name##_globals[max_num];			\
									\
	static type *							\
	sa_##name##_alloc_at_index(unsigned int idx)			\
	{								\
		type *c = NULL;						\
		word_t *s;						\
									\
		if (idx >= max_num) return NULL;			\
		c = &sa_##name##_globals[idx];				\
		s = &sa_##name##_states[idx];				\
		if (*s != (word_t)SA_OBJ_FREE ||			\
		    !ps_cas(s, SA_OBJ_FREE, SA_OBJ_CONSTRUCTING)) return NULL; \
		memset(c, 0, sizeof(type));				\
									\
		return c;						\
	}								\
	static type *							\
	sa_##name##_alloc(void)						\
	{								\
		unsigned int i;						\
		type *c = NULL;						\
									\
		for (i = 0; i < max_num; i++) {				\
			c = sa_##name##_alloc_at_index(i);		\
			if (c) break;					\
		}							\
		if (i >= max_num) return NULL;				\
									\
		return c;						\
	}								\
	static unsigned int						\
	sa_##name##_index(type *o)					\
	{								\
		assert(o >= &sa_##name##_globals[0] &&			\
		       o <= &sa_##name##_globals[max_num - 1]);		\
		return o - &sa_##name##_globals[0];			\
	}								\
	static void							\
	sa_##name##_activate(type *o)					\
	{								\
		unsigned int idx = sa_##name##_index(o);		\
		word_t *s        = &sa_##name##_states[idx];		\
									\
		assert(*s == SA_OBJ_CONSTRUCTING);			\
		/* no cas as we're the only one accessing */		\
		*s = SA_OBJ_ALLOCATED;					\
	}								\
	static void							\
	sa_##name##_free(type *o)					\
	{								\
		word_t *s = &sa_##name##_states[sa_##name##_index(o)];	\
									\
		*s = (word_t)SA_OBJ_FREE;				\
	}								\
	static type *							\
	sa_##name##_get(unsigned int idx)				\
	{								\
		type *o;						\
									\
		if (idx >= max_num) return NULL;			\
		o = &sa_##name##_globals[idx];				\
		if (sa_##name##_states[idx] != SA_OBJ_ALLOCATED) return NULL; \
									\
		return o;						\
	}

#endif	/* STATIC_ALLOC_H */
